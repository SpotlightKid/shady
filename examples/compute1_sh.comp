#version 430
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
// from commandsToImage

float[63] hits;
uniform samplerBuffer inputCommandBuffer;
int ip = 0;
int hitCount = 0;
uniform ivec4 dimensions;
writeonly uniform uimageBuffer outputImageBuffer;
vec4[899] colorBuffer;
vec4[899] colorBufferAA;
int[63] hitsWinding;

uint readInt();
void commandsInner(vec2 pos, vec2 aa);
float readFloat();
void writeColor(vec2 pos, vec4 color);


uint readInt(
) {
  uint result;
  result = uint(texelFetch(inputCommandBuffer, ip).x);
  ip += 1;
  return result;
}

void commandsInner(
  vec2 pos,
  vec2 aa
) {
  float scanY = pos.y;
  ip = int(0);
  hitCount = int(0);
  while(true) {
    uint opcode = readInt();
    if (opcode == uint(0)) {
      break;
    }
    if (opcode == uint(2)) {
      vec4 fillColor = vec4(readFloat(), readFloat(), readFloat(), readFloat());
      if (int(0) < hitCount) {
        int atHit = 0;
        int pen = 0;
        for(int x = int(0); x < dimensions.x; x++) {
          while((atHit < int(hitCount)) && (hits[atHit] <= float(x))) {
            pen += int(hitsWinding[atHit]);
            atHit += 1;
          }
          if (! (pen == 0)) {
            colorBuffer[x] = fillColor;
          }
        }
        hitCount = int(0);
      }
    }
    if (opcode == uint(1)) {
      vec2 at = vec2(readFloat(), readFloat()) + aa;
      vec2 to = vec2(readFloat(), readFloat()) + aa;
      float winding = readFloat();
      float m = (at.y - to.y) / (at.x - to.x);
      float b = at.y - m * at.x;
      if ((scanY <= min(at.y, to.y)) || (max(at.y, to.y) < scanY)) {
        ;
      } else {
        float x = 0.0;
        if (float(abs(at.x - to.x)) < 0.0003141592653589793) {
          x = at.x;
        } else {
          x = (scanY - b) / (m);
        }
        hits[hitCount] = x;
        hitsWinding[hitCount] = int(winding);
        hitCount += 1;
        int i = hitCount - int(1);
        while(! (i == int(0))) {
          if (hits[i] < hits[i - int(1)]) {
            float tmp = hits[i - int(1)];
            hits[i - int(1)] = hits[i];
            hits[i] = tmp;
            int tmpWinding = hitsWinding[i - int(1)];
            hitsWinding[i - int(1)] = hitsWinding[i];
            hitsWinding[i] = tmpWinding;
            i -= 1;
          } else {
            break;
          }
        }
      }
    }
  }
}

float readFloat(
) {
  float result;
  result = texelFetch(inputCommandBuffer, ip).x;
  ip += 1;
  return result;
}

void writeColor(
  vec2 pos,
  vec4 color
) {
  uvec4 colorValue = uvec4(uint(color.x * 255.0), uint(color.y * 255.0), uint(color.z * 255.0), uint(color.w * 255.0));
  imageStore(outputImageBuffer, int(uint(pos.y) * uint(dimensions.x) + uint(pos.x)), colorValue);
}

void main() {
  uvec3 pos = gl_GlobalInvocationID;
  for(int x = int(0); x < dimensions.x; x++) {
    colorBufferAA[x] = vec4(0.0, 0.0, 0.0, 0.0);;
  }
  int aa = 2;
  for(int aaX = 0; aaX < aa; aaX++) {
    for(int aaY = 0; aaY < aa; aaY++) {
      for(int x = int(0); x < dimensions.x; x++) {
        colorBuffer[x] = vec4(0.0, 0.0, 0.0, 0.0);;
      }
      commandsInner(vec2(pos.xy), vec2(float(aaX), float(aaY)) / float(aa));
      for(int x = int(0); x < dimensions.x; x++) {
        colorBufferAA[x] += colorBuffer[x];;
      }
    };
  }
  for(int x = int(0); x < dimensions.x; x++) {
  writeColor(vec2(float(x), float(pos.y)), colorBufferAA[x] / float(aa * aa));
  }
}
